// SHEEKA - Database Schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("POSTGRES_PRISMA_URL") // uses connection pooling
  directUrl = env("POSTGRES_URL_NON_POOLING") // uses a direct connection
}

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  name         String
  passwordHash String
  role         String   @default("MEMBER")
  title        String? // Wellness Coach, etc.
  lineUserId   String?  @unique // LINE User ID for messaging and login
  lineDisplayName String? // NEW: LINE Display Name
  linePictureUrl String?  // NEW: LINE Profile Picture URL
  isLineFriend  Boolean  @default(false) // NEW: True if currently following
  unitPrice    Int? // 6050, etc.
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  memberProfile    Member?       @relation("UserAsMember")
  trainingSessions TrainingLog[] @relation("TrainerSessions")
  assignedPromises Promise[]     @relation("AssignedByTrainer")
  assignedMembers  Member[]      @relation("MainTrainer")
  reservations     Reservation[]
  accounts         Account[]    // NextAuth relation
  chats            ChatMessage[] // CRM: 1:1 Chat
  tags             Tag[]         // CRM: User Tags
  currentRichMenuId String?      // CRM: Current Rich Menu
  richMenu         RichMenu?     @relation(fields: [currentRichMenuId], references: [id])

  @@map("users")

  // Relations for CRM
  attributeValues UserAttributeValue[]
  formSubmissions FormSubmission[]
  stepProgress    UserStepProgress[]
  segments        UserSegment[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Member {
  id               String   @id @default(cuid())
  userId           String?  @unique
  name             String
  dateOfBirth      DateTime
  gender           String
  phone            String
  emergencyContact String

  // Profile & Vision
  medicalHistory   String?
  exerciseHistory  String? // NEW
  height           Float? // NEW: Height in cm
  currentCondition String? // NEW: Current injuries/illness
  goals            String?
  purpose          String? // NEW
  vision           String? // NEW

  experienceLevel    String   @default("BEGINNER")
  joinDate           DateTime @default(now())
  isActive           Boolean  @default(true)
  rank               String   @default("REGULAR") // BRONZE, SILVER, GOLD, PLATINUM
  plan               String   @default("STANDARD") // STANDARD, EMPLOYEES, VIP
  manualDiscountRate Int? // Optional manual override for discount percentage
  contractedSessions Int      @default(4) // Number of sessions included in monthly contract
  mainTrainerId      String? // ID of the designated main trainer
  prepaidBalance     Int      @default(0) // NEW: Digital Prepaid Balance
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  user             User?             @relation("UserAsMember", fields: [userId], references: [id])
  mainTrainer      User?             @relation("MainTrainer", fields: [mainTrainerId], references: [id])
  trainingLogs     TrainingLog[]
  lifeLogs         LifeLog[]
  conditioningLogs ConditioningLog[] // NEW

  promises     Promise[]
  reservations Reservation[]
  bodyRecords  BodyRecord[]
  bookings     Booking[] // NEW: For booking calendar system
  tickets      Ticket[]  // NEW: Ticket system

  @@map("members")
}

model Ticket {
  id          String   @id @default(cuid())
  memberId    String
  title       String   // "5 Trial Sessions", "Standard Ticket"
  type        String   // "LIMITED", "UNLIMITED"
  initialCount Int     // e.g. 5
  remainingCount Int   // e.g. 5 -> 4 -> ...
  expiryDate  DateTime?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  member      Member   @relation(fields: [memberId], references: [id], onDelete: Cascade)

  @@map("tickets")
}

model ConditioningLog {
  id         String   @id @default(cuid())
  memberId   String
  date       DateTime @default(now())
  stiffness  String? // 硬い部位
  weakness   String? // 弱い部位
  adjustment String? // 調整箇所
  notes      String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  member Member @relation(fields: [memberId], references: [id], onDelete: Cascade)

  @@map("conditioning_logs")
}

model BodyRecord {
  id        String   @id @default(cuid())
  memberId  String
  date      DateTime
  photoUrl  String // URL to storage (or base64 for demo)
  weight    Float?
  notes     String?
  createdAt DateTime @default(now())

  member Member @relation(fields: [memberId], references: [id], onDelete: Cascade)

  @@map("body_records")
}

model TrainingLog {
  id              String   @id @default(cuid())
  memberId        String
  trainerId       String?
  trainingDate    DateTime
  durationMinutes Int
  notes           String?
  transcript      String? // AI Speech-to-Text
  aiSummary       String? // AI Generated Summary
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  member  Member        @relation(fields: [memberId], references: [id], onDelete: Cascade)
  trainer User?         @relation("TrainerSessions", fields: [trainerId], references: [id])
  sets    TrainingSet[]

  @@map("training_logs")
}

model TrainingSet {
  id                 String   @id @default(cuid())
  trainingLogId      String
  exerciseName       String
  setNumber          Int
  weight             Float
  reps               Int
  restSeconds        Int? // Rest time after set
  estimatedOneRepMax Float?
  notes              String?
  createdAt          DateTime @default(now())

  trainingLog TrainingLog @relation(fields: [trainingLogId], references: [id], onDelete: Cascade)

  @@map("training_sets")
}

model LifeLog {
  id           String   @id @default(cuid())
  memberId     String
  logDate      DateTime
  steps        Int?
  weight       Float?
  sleepMinutes Int?
  mood         String?
  notes        String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  member Member @relation(fields: [memberId], references: [id], onDelete: Cascade)

  @@unique([memberId, logDate])
  @@map("life_logs")
}

model Promise {
  id          String   @id @default(cuid())
  memberId    String
  assignedBy  String
  title       String
  description String?
  dueDate     DateTime
  status      String   @default("PENDING")
  category    String   @default("OTHER")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  member      Member              @relation(fields: [memberId], references: [id], onDelete: Cascade)
  trainer     User                @relation("AssignedByTrainer", fields: [assignedBy], references: [id])
  completions PromiseCompletion[]

  @@map("promises")
}

model PromiseCompletion {
  id            String   @id @default(cuid())
  promiseId     String
  completedDate DateTime
  note          String?
  createdAt     DateTime @default(now())

  promise Promise @relation(fields: [promiseId], references: [id], onDelete: Cascade)

  @@map("promise_completions")
}

model Reservation {
  id        String   @id @default(cuid())
  memberId  String
  trainerId String
  startTime DateTime
  endTime   DateTime
  status    String   @default("CONFIRMED")
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  member  Member @relation(fields: [memberId], references: [id], onDelete: Cascade)
  trainer User   @relation(fields: [trainerId], references: [id])

  @@map("reservations")
}

model MasterExercise {
  id        String   @id @default(cuid())
  name      String   @unique
  category  String // Chest, Back, Legs, Shoulders, Arms, Abs, Other
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("master_exercises")
}

// ===== BOOKING CALENDAR SYSTEM =====

model Staff {
  id        String   @id @default(cuid())
  name      String
  type      String // "trainer" | "self-room"
  color     String   @default("#3b82f6")
  isActive  Boolean  @default(true)
  maxConcurrentBookings Int @default(1) // NEW: Concurrent booking limit
  unitPrice Int      @default(0) // NEW: Price per session for prepaid deduction
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  shifts         Shift[]
  shiftOverrides ShiftOverride[]
  bookings       Booking[]

  @@map("staff")
}

model Shift {
  id        String   @id @default(cuid())
  staffId   String
  staff     Staff    @relation(fields: [staffId], references: [id], onDelete: Cascade)
  dayOfWeek Int // 0=Sunday, 1=Monday, ..., 6=Saturday
  startTime String // "09:00" format
  endTime   String // "18:00" format
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([staffId, dayOfWeek])
  @@map("shifts")
}

model ShiftOverride {
  id        String   @id @default(cuid())
  staffId   String
  staff     Staff    @relation(fields: [staffId], references: [id], onDelete: Cascade)
  date      DateTime // Specific date for override
  startTime String? // null = day off
  endTime   String? // null = day off
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([staffId, date])
  @@map("shift_overrides")
}

model ServiceMenu {
  id          String   @id @default(cuid())
  name        String
  duration    Int      // Duration in minutes
  price       Int      @default(0)
  description String?
  categoryId  String?  // Optional grouping
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  bookings    Booking[]

  @@map("service_menus")
}

model Booking {
  id            String   @id @default(cuid())
  memberId      String
  member        Member   @relation(fields: [memberId], references: [id], onDelete: Cascade)
  staffId       String
  staff         Staff    @relation(fields: [staffId], references: [id])
  serviceMenuId String?  // NEW: Link to Service Menu
  serviceMenu   ServiceMenu? @relation(fields: [serviceMenuId], references: [id])
  
  startTime     DateTime
  endTime       DateTime
  status        String   @default("confirmed") // "pending" | "confirmed" | "cancelled"
  googleEventId String? // Google Calendar event ID for sync
  type          String   @default("REGULAR") // REGULAR, ADDITIONAL, TRANSFER_MEMBER, TRANSFER_STORE, TRIAL
  cancellationReason String? // "SICKNESS" | "BEREAVEMENT" | "REST" | "OTHER" | "NORMAL"
  notes         String?
  paidFromPrepaid Int     @default(0) // NEW: Amount paid using prepaid balance
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([staffId, startTime])
  @@index([memberId])
  @@map("bookings")
}

// ===== CRM SYSTEM (L-Message Style) =====

model RichMenu {
  id        String   @id @default(cuid())
  lineMenuId String  @unique // ID from LINE Platform
  name      String   // Internal name
  imageUrl  String?  // Storage URL for the menu image
  chatBarText String @default("メニューを開く")
  selected  Boolean  @default(false) // Default selection
  jsonConfig Json    // Full JSON configuration for LINE API
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users     User[]
  
  @@map("rich_menus")
}

model Tag {
  id        String   @id @default(cuid())
  name      String   @unique
  color     String   @default("#94a3b8") // UI color definition
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users     User[]

  @@map("tags")
}

model ChatMessage {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  sender    String   // "USER" | "ADMIN"
  content   String   // Text content (simplified for now)
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([userId])
  @@map("chat_messages")
}

model AutoResponse {
  id        String   @id @default(cuid())
  keyword   String   @unique // Exact match for simplicity first
  response  String   // Reply text
  isActive  Boolean  @default(true)
  matchType String   @default("EXACT") // "EXACT" | "PARTIAL" | "REGEX"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("auto_responses")
}

// ===== MESSAGING SYSTEM =====

model Broadcast {
  id          String   @id @default(cuid())
  title       String   // Internal use
  content     Json     // LINE message object(s)
  targetFilter Json?   // Segment rules or specific user IDs
  scheduledAt DateTime?
  status      String   @default("DRAFT") // DRAFT, SCHEDULED, SENDING, SENT, FAILED
  sentCount   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("broadcasts")
}

model StepSequence {
  id        String   @id @default(cuid())
  name      String
  triggerType String // "TAG_ADDED", "FRIEND_ADDED", "FORM_SUBMITTED"
  triggerValue String? // Tag ID or Form ID
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages  StepMessage[]
  progress  UserStepProgress[]

  @@map("step_sequences")
}

model StepMessage {
  id          String   @id @default(cuid())
  sequenceId  String
  sequence    StepSequence @relation(fields: [sequenceId], references: [id], onDelete: Cascade)
  delayDays   Int      @default(0) // Days after trigger
  timeOfDay   String?  // Specific time "10:00". If null, use relative delay
  content     Json     // LINE message objects
  orderIndex  Int
  createdAt   DateTime @default(now())

  @@map("step_messages")
}

model UserStepProgress {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  sequenceId  String
  sequence    StepSequence @relation(fields: [sequenceId], references: [id], onDelete: Cascade)
  
  nextMessageOrder Int @default(0)
  scheduledAt DateTime // When the next message should be sent
  status      String   @default("ACTIVE") // ACTIVE, COMPLETED, CANCELLED
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId, sequenceId])
  @@index([scheduledAt]) // For cron job
  @@map("user_step_progress")
}

// ===== FORMS & SURVEYS =====

model Form {
  id          String   @id @default(cuid())
  title       String
  description String?
  isActive    Boolean  @default(true)
  actions     Json?    // e.g., { "addTags": ["tag_id"], "startStep": "seq_id" }
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  questions   FormQuestion[]
  submissions FormSubmission[]

  @@map("forms")
}

model FormQuestion {
  id          String   @id @default(cuid())
  formId      String
  form        Form     @relation(fields: [formId], references: [id], onDelete: Cascade)
  type        String   // "TEXT", "TEXTAREA", "SELECT", "RADIO", "CHECKBOX", "DATE"
  label       String
  options     Json?    // Array of strings for choices
  required    Boolean  @default(false)
  orderIndex  Int
  
  answers     FormAnswer[]

  @@map("form_questions")
}

model FormSubmission {
  id          String   @id @default(cuid())
  formId      String
  form        Form     @relation(fields: [formId], references: [id], onDelete: Cascade)
  userId      String?  // Can be anonymous initially, but usually linked
  user        User?    @relation(fields: [userId], references: [id])
  createdAt   DateTime @default(now())

  answers     FormAnswer[]

  @@map("form_submissions")
}

model FormAnswer {
  id           String   @id @default(cuid())
  submissionId String
  submission   FormSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  questionId   String
  question     FormQuestion   @relation(fields: [questionId], references: [id])
  value        String   // Text value or JSON string for multiple selection

  @@map("form_answers")
}

// ===== CUSTOMER ATTRIBUTES & SEGMENTS =====

model CustomAttribute {
  id        String   @id @default(cuid())
  key       String   @unique // Internal key e.g. "favorite_color"
  label     String   // Display label e.g. "好きな色"
  type      String   // "TEXT", "NUMBER", "DATE", "SELECT"
  options   Json?    // Choices for SELECT
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  values    UserAttributeValue[]

  @@map("custom_attributes")
}

model UserAttributeValue {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  attributeId String
  attribute   CustomAttribute @relation(fields: [attributeId], references: [id], onDelete: Cascade)
  value       String   // Store as string, cast when reading

  @@unique([userId, attributeId])
  @@map("user_attribute_values")
}

model Segment {
  id          String   @id @default(cuid())
  name        String
  rules       Json     // Complex filtering logic
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  users       UserSegment[]

  @@map("segments")
}

model UserSegment {
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  segmentId String
  segment   Segment  @relation(fields: [segmentId], references: [id], onDelete: Cascade)
  assignedAt DateTime @default(now())

  @@id([userId, segmentId])
  @@map("user_segments")
}
